<!DOCTYPE html>
<!--
 * @Author: liuZiHao Nero
 * @Github: https://github.com/nero90011
 * @E-mail: 601412402@qq.com
 * @Company: myself
 * @Date: 2019-06-09 14:59:32
 * @LastEditTime: 2019-09-16 11:15:17
 * @LastEditors: Do not edit
 * @Description: 
 -->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <progress min="0" max="100" value="0">0% complete</progress>
</body>
<script>
  /* eslint-disable */
    /* 
      检测设备类型
    */
    const detectDeviceType = () =>/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|OperaMini/i.test(navigator.userAgent) ? 'Mobile' : 'Desktop';
  
  
    /*
     *  window.location.search转JS对象
     *  从问号 (?)后 开始的 URL（查询部分）进行转换
    */
    const searchObj = search => JSON.parse(`{"${decodeURIComponent(search.substring(1)).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"')}"}`);
    const objectToQueryString = (obj) => Object.keys(obj).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`).join('&');
    objectToQueryString({name: 'Jhon', age: 18, address: 'beijing'})
    // name=Jhon&age=18&address=beijing
    
    
    /**
    浏览器存储
    */

    //1.cookie  document.cookie属性用于读写当前网页的 Cookie。
    document.cookie = 'fontSize=14; '+
     'expires=' + someDate.toGMTString() + '; ' +
    'path=/subdirectory; ' +
    'domain=*.example.com';   //写
    //删除cookie
    document.cookie = 'fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT';
    //读取cookie
    // doucment.cookie; //返回字符串,最好验证下是否为null
    
    //2.localStorage
    window.localStorage.foo = '123';
    window.localStorage['foo'] = '123';
    window.localStorage.setItem('foo', '123');
    window.localStorage.setItem('key','value');
    window.localStorage.length;
    window.localStorage.getItem('key');
    window.localStorage.removeItem('key');
    window.localStorage.clear();
    window.localStorage.key(0);//返回对象位置键值对
    window.addEventListener('storage',(event)=>{
        event.key;
        event.newValue;
        event.oldValue;
        event.storageArea;
        event.url;
    });
    //3.sessionStorage 同上
    //4.IndexedDB
    

    
    
    
    
    
    /**
    location对象
    Location.href：整个 URL。
    Location.protocol：当前 URL 的协议，包括冒号（:）。
    Location.host：主机，包括冒号（:）和端口（默认的80端口和443端口会省略）。
    Location.hostname：主机名，不包括端口。
    Location.port：端口号。
    Location.pathname：URL 的路径部分，从根路径/开始。
    Location.search：查询字符串部分，从问号?开始。
    Location.hash：片段字符串部分，从#开始。
    Location.username：域名前面的用户名。
    Location.password：域名前面的密码。
    Location.origin：URL 的协议、主机名和端口。

    assign方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。
    它与assign方法的差异在于，replace会在浏览器的浏览历史History里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。它的一个应用是，当脚本发现当前是移动设备时，就立刻跳转到移动版网页。
    reload方法使得浏览器重新加载当前网址，相当于按下浏览器的刷新按钮。
    toString方法返回整个 URL 字符串，相当于读取Location.href属性。
    
    URL对象
    URL.href：返回整个 URL
    URL.protocol：返回协议，以冒号:结尾
    URL.hostname：返回域名
    URL.host：返回域名与端口，包含:号，默认的80和443端口会省略
    URL.port：返回端口
    URL.origin：返回协议、域名和端口
    URL.pathname：返回路径，以斜杠/开头
    URL.search：返回查询字符串，以问号?开头
    URL.searchParams：返回一个URLSearchParams实例，该属性是Location对象没有的
    URL.hash：返回片段识别符，以井号#开头
    URL.password：返回域名前面的密码
    URL.username：返回域名前面的用户名
    只有origin属性是只读的，其他属性都可写。

    */

    
    /**
    ajax XMLHttpRequest
    */
    function upload(blobOrFile) {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', '/server', true);
        xhr.onload = function (e) {};

        var progressBar = document.querySelector('progress');
        xhr.upload.onprogress = function (e) {
            if (e.lengthComputable) {
                progressBar.value = (e.loaded / e.total) * 100;
                // 兼容不支持 <progress> 元素的老式浏览器
                progressBar.textContent = progressBar.value;
            }
        };

        xhr.send(blobOrFile);
    }

    upload(new Blob(['hello world'], {
        type: 'text/plain'
    }));
    /**
    同源:
        协议相同
        域名相同
        端口相同
    （1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。

    （2） 无法接触非同源网页的 DOM。

    （3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。


    Cookie共享
      如果只是次级域名不同:
                // 两个网页都需要设置
                document.domain = 'example.com';
    iframe共享
        1.同上
        2.完全不同源:
            h5新增api:
                // 父窗口打开一个子窗口
                var popup = window.open('http://bbb.com', 'title');
                // 父窗口向子窗口发消息
                popup.postMessage('Hello World!', 'http://bbb.com');
                // 父窗口和子窗口都可以用下面的代码，
                // 监听 message 消息
                window.addEventListener('message', receiveMessage);
                function receiveMessage(event) {
                if (event.origin !== 'http://aaa.com') return;
                if (event.data === 'Hello World') {
                    event.source.postMessage('Hello', event.origin);
                } else {
                    console.log(event.data);
                }
                }
    ajax共享
        1.jsonp
                function addScriptTag(src) {
                var script = document.createElement('script');
                script.setAttribute('type', 'text/javascript');
                script.src = src;
                document.body.appendChild(script);
                }

                window.onload = function () {
                addScriptTag('http://example.com/ip?callback=foo');
                }

                function foo(data) {
                console.log('Your public IP address is: ' + data.ip);
                };
                上面代码通过动态添加<script>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于 JSONP 是必需的。

                服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。

                foo({
                'ip': '8.8.8.8'
                });
                由于<script>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。
        2.websocket
                服务器:Access-Control-Allow-Credentials: true
                前台:ajax中:
                var xhr = new XMLHttpRequest();
                xhr.withCredentials = true;
                var url = 'http://api.alice.com/cors';
                var xhr = new XMLHttpRequest();
                xhr.open('PUT', url, true);
                xhr.setRequestHeader('X-Custom-Header', 'value');
                xhr.send();
        3.cors
    */
    // 加强版的子窗口接收消息的代码如下。

    window.onmessage = function (e) {
        if (e.origin !== 'http://bbb.com') return;
        var payload = JSON.parse(e.data);
        switch (payload.method) {
            case 'set':
                localStorage.setItem(payload.key, JSON.stringify(payload.data));
                break;
            case 'get':
                var parent = window.parent;
                var data = localStorage.getItem(payload.key);
                parent.postMessage(data, 'http://aaa.com');
                break;
            case 'remove':
                localStorage.removeItem(payload.key);
                break;
        }
    };
    // 加强版的父窗口发送消息代码如下。

    var win = document.getElementsByTagName('iframe')[0].contentWindow;
    var obj = {
        name: 'Jack'
    };
    // 存入对象
    win.postMessage(
        JSON.stringify({
            key: 'storage',
            method: 'set',
            data: obj
        }),
        'http://bbb.com'
    );
    // 读取对象
    win.postMessage(
        JSON.stringify({
            key: 'storage',
            method: "get"
        }),
        "*"
    );
    window.onmessage = function (e) {
        if (e.origin != 'http://aaa.com') return;
        console.log(JSON.parse(e.data).name);
    };
</script>

</html>