<!DOCTYPE html>
<!--
 * @Author: liuZiHao Nero
 * @Github: https://github.com/nero90011
 * @E-mail: 601412402@qq.com
 * @Company: myself
 * @Date: 2019-05-28 15:13:19
 * @LastEditTime: 2019-09-16 14:03:28
 * @LastEditors: Do not edit
 * @Description: 
 * @Link:有关兼容性请看https://segmentfault.com/q/1010000005757406
 -->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>11_Promise对象</title>
  </head>

  <body>
    <!--
1. 理解:
  * Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作)
  * 有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称'回调地狱')
  * ES6的Promise是一个构造函数, 用来生成promise实例
2. 使用promise基本步骤(2步):
  * 创建promise对象              解决      拒绝            
    let promise = new Promise((resolve, reject) => {
        //初始化promise状态为 pending(等待)
      //执行异步操作
      if(异步操作成功) {
        resolve(value);//修改promise的状态为fullfilled
      } else {
        reject(errMsg);//修改promise的状态为rejected
      }
    })
  * 调用promise的then()
    1.promise.then(function(
      result => console.log(result),
      errorMsg => alert(errorMsg)
    ))
    2.或者调用promise的catch()  只是then的一个别名
    3.或者使用  需要1,2状态都为resolve才行
    Promise.all([primise1,promise2].then((value)=>{
      ...
    }))
3. promise对象的3个状态
  * pending: 初始化状态
  * fullfilled: 成功状态
  * rejected: 失败状态
4. 应用:
  * 使用promise实现超时处理

  * 使用promise封装处理ajax请求
-->

    <script type="text/javascript">
    /* eslint-disable*/
      /**
       * promise练习
       * 定义获取新闻功能的函数
       */
      class promiseTest {
        //编写一个promise工具函数 返回一个
            //promise函数  符合条件则resolve否则reject 并使用Promise.error抛出错误
        promiseAJAX(url) {
          return new Promise((resolve, reject) => {
            let xmlHttp = new XMLHttpRequest();
            xmlHttp.onreadystatechange = () => {
              if (xmlHttp.readyState === 4) {
                if (xmlHttp.status == 200) {
                  resolve(xmlHttp.responseText); //包含data 和 error
                } else {
                  reject(Promise.error("   "));
                }
              }
            };
            xmlHttp.open("GET", url);
            xmlHttp.send();
          });
        }
        //编写使用primise工具函数的函数
          //编写内容:使用then进行逻辑顺序操作
            //使用renturn promise进行下一个then的起步 使用catch进行错误抓取
        dopromise(url) {
          promiseAJAX(url)
            .then(
              data => {
                console.log(data);
                //发送请求获取评论内容 准备url
                let commentsUrl = JSON.parse(data).commentsUrl;
                let url = "http://localhost:3000" + commentsUrl;
                //发送请求
                return promiseAJAX(url);
              },
              error => {
                console.log(error);
              }
            )
            .catch(err => {})
            .then(
              data => {
                //把回调样子上改成单线,本质还是回调
                console.log(data);
              },
              error => {
                console.log(error);
              }
            )
            .catch(err => {});
        }
      }
      let test1 = new promiseTest();
      test1.dopromise('http://localhost:3000/news?id=2');

      
 

      /* 
          坑:异步和同步操作
        
       */
      //先输出2再输出3
      let promise2 = new Promise((resolve, reject) => {
        console.log(1);
        resolve(3);
      });
      promise2
        .then(result => {
          console.log(result);
        })
        .catch(err => {});
      console.log(2);
      /* 解决异步同步混乱问题 */
      function readyPromise() {
        return new Promise(function(resolve, reject) {
          var readyState = document.readyState;
          if (readyState === "interactive" || readyState === "complete") {
            resolve();
          } else {
            window.addEventListener("DOMContentLoaded", resolve);
          }
        });
      }
      readyPromise().then(function() {
        console.log("DOM Load Success");
      });
      console.log("我是同步加载的，先执行我");
    </script>
  </body>
</html>
