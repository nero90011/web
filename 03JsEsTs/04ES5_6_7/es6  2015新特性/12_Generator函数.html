<!DOCTYPE html>
<!--
 * @Author: liuZiHao Nero
 * @Github: https://github.com/nero90011
 * @E-mail: 601412402@qq.com
 * @Company: myself
 * @Date: 2019-05-28 15:13:19
 * @LastEditTime: 2019-08-18 18:14:17
 * @LastEditors: Do not edit
 * @Description:
 -->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Generator函数</title>
  </head>

  <body>
    <script type="text/javaScript">
        /* 
        function* simpleg () {
          try {
            const t1= yield 1;
            const t2=yield 2;
          } catch (e) {
          
          }
        }
        const sg=simpleg();
        sg().next(1);
        
        
        
          Genereator是es6提供的一种异步编程解决方案
          也叫惰性函数  或者 状态机函数
          1.理解:
            generator函数是一个状态机,封装了多个内部状态
            他会返回遍历器对象 可以一次便利generator函数内部的每一个装填
            形式上是一个普通函数   特征  * 和 yield
            调用时返回的是一个指向内部状态的指针对象iterator
          2.执行顺序
            新建  let t1 =test1()  无需new
            首次执行t1().next()   执行到第一个yield的表达式后停止
            二次执行t2().next()   从第一个yield开始执行
                                  到第二个yield停止
            ....
          3.yield表达式
            yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行
            可以没有yield语句  此时就变成了一个单纯的暂缓执行的函数
            yield表达式只能用在generator函数中,其他地方会报错,比如foreach
            yield表达式如果用在另一个表达式中必须放在圆括号里面如:
                console.log('Hello'+(yield));
                console.log()
            不用加括号的情况:
                foo(yield 'a');
                let input =yield 1;
            yield本身没有返回值
          4.next方法参数
            next的参数是 上一个yield表达式的返回值
                此功能很重要:可以在generator运行的不同阶段从外向内注入不同的值
            V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。
            从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数
          5.for of
            可以自动遍历generator函数运行时产生的iterator对象,不需要再调用next方法
            就相当于调用了next()方法
          6.throw()方法
            generator函数返回的遍历器对象,都有一个throw方法,可以再函数体外抛出错误
            然后再generator函数体内捕获
            //注意区别 全局throw 和iterator的throw
                //外部可捕获内部  内部可捕获外部
            //有几个catch就只能捕获几个错误,
                //如果catch不足那么多的i.throw会被外部trycatch捕获
                //如果内外都没有catch但throw了则程序报错,终端执行
                //必须执行一次next方法后 i.throw 才会被内部catch捕获否则外部或报错
            //throw可以写进参数,建议使用Error对象实例
            //i.throw被内部catch捕获后多执行一次next方法
            //一旦generator执行过程中抛出错误而没有被内部捕获则就不会再执行下去了
                //之后滴啊用的next方法都会返回value=undefined done=true的对象
          7.return()
            //g.return("返回特定的值")  并终结遍历generator函数
            //Generator.prototype.return()
            //返回给定值,遍历generator函数
            //如果return空 则value为undefined
            //如果有finally则g.return会在finally执行完后再执行
          8.next throw return 作用都是让generator函数恢复执行,并使用不同的语句替换
          9.yield * 参数
            //在一个g中执行另一个g使用 相当于for of
            //如果参数是数组 字符串或其他有iterator接口的数据结构就会返回其对应的遍历器对象
              //如 yield* 'hello'   read.next().value//'h'
            //如果被代理的generator函数有return语句,那么就可以像代理它的generator函数返回数据
            //yield* 命令可以很方便的取出嵌套数组的所有成员
          10.应用:
            //异步操作的同步化表达  如 界面加载 ajax  手动逐行读取文本文件
            //控制流管理  多个函数调用嵌套 promise改成执行执行形式 generator函数进一步改善代码运行流程


      */


      
      //例1: 存在三种状态
      function* test1 () {
        let value=yield 'hello';
        console.log(value);
        yield 'world';
        return 'ending';
      }
      let t1=test1();
      console.log('====================================');
      console.log(t1.next("1"));//{ value: 'hello', done: false }
      console.log(t1.next("2"));//
      console.log(t1.next());//{ value: 'ending', done: true }
      console.log(t1.next());//{ value: undefined, done: true }
      console.log('====================================');


      //2.与iterator接口关系
      let obj={};
      obj[Symbol.iterator]=function*  () {
        yield 1;
        yield 2;
        yield 3;
      };
      console.log('====================================');
      console.log([...obj]);
      console.log('====================================');



      //3.forof  斐波那契数列
      function* fibonacci () {
        let [prev,curr]=[0,1];
        for(;;){
          yield curr;
          [prev,curr]=[curr,prev+curr];
        }
      }
      //for of相当于每次调用next()
      for (const iterator of fibonacci()) {
        if(iterator>1000) break;
        console.log(iterator);
      }


      //4.原生对象使用forof的方法
        //第一种
      function* objectEntries() {
          let propKeys = Object.keys(this);

      for (let propKey of propKeys) {
        yield [propKey, this[propKey]];
      }
      }
      let jane = { first: 'Jane', last: 'Doe' };

      jane[Symbol.iterator] = objectEntries;

      for (let [key, value] of jane) {
        console.log(`${key}: ${value}`);
      }
      //...
      //Array.form等



      //5.throw  iterator函数体外抛出 函数体catch捕获

      const gt=function*  () {
        try {
          let x=yield console.log(3);
          let y=x.toUpperCase
        } catch (e) {
          console.log(e);
        }
        yield console.log(2);
        yield console.log(3);
      }
      
      try {
        let i=gt();
        i.next();
        i.next(42)
        i.throw(new Error('出错误了!,请重试1'));
        i.throw(new Error('出错误了!,请重试2'));

      } catch (e) {
          console.log(e);
          console.log("generate内部出错");
      }




      //6.Generator.prototype.return()
          //返回给定值,丁姐遍历generator函数
          //如果return空则value为undefined
          //如果有finally则g.return会在finally执行完后再执行
      function* returnTest () {
        try {
          yield 1;
          yield 2;
          yield 3;
        } catch (e) {

        }finally{
          yield 4;
          yield 5;
        }
        yield 6;
      }
      let g=returnTest();
      console.log(g.next());//{ value: 1, done: false }
      console.log(g.return('foo'));//{ value: 'foo', done: true }
      console.log(g.next());//{ value: undefined, done: true }



      //7 yield*
          //如果被代理的generator函数有return语句,那么就可以像代理它的generator函数返回数据
          //yield* 命令可以很方便的取出嵌套数组的所有成员
      function* yieldX () {
        yield* 'hello';
      }
      console.log(yieldX().next().value);//h

        //yield* 嵌套数组的平铺  可以很方便的取出嵌套数组的所有成员
        function* iterTree (tree) {
            if(Array.isArray(tree)){
              for(let i=0;i<tree.length;i++){
                yield* iterTree(tree[i]) ;
              }
            }else{
              yield tree;
            }
        }
        const tree=['a',['b','c'],['d','e']];
        for(let x of iterTree(tree)){
          console.log(x);
        }
        console.log('====================================');
        console.log([...iterTree(tree)]);
        console.log('====================================');
        //遍历二叉树
        // 下面是二叉树的构造函数，
        // 三个参数分别是左树、当前节点和右树
        function Tree(left, label, right) {
          this.left = left;
          this.label = label;
          this.right = right;
        }

        // 下面是中序（inorder）遍历函数。
        // 由于返回的是一个遍历器，所以要用generator函数。
        // 函数体内采用递归算法，所以左树和右树要用yield*遍历
        function* inorder(t) {
          if (t) {
            yield* inorder(t.left);
            yield t.label;
            yield* inorder(t.right);
          }
        }

        /* 遍历二叉树 */
        // 下面生成二叉树
        function make(array) {
          // 判断是否为叶节点
          if (array.length == 1) return new Tree(null, array[0], null);
          return new Tree(make(array[0]), array[1], make(array[2]));
        }
        let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);

        // 遍历二叉树
        var result = [];
        for (let node of inorder(tree)) {
          result.push(node);
        }

        result
        // ['a', 'b', 'c', 'd', 'e', 'f', 'g']




      //8.应用:ajax
          //控制流管理
      /*
      * 需求：
      * 1、发送ajax请求获取新闻内容
      * 2、新闻内容获取成功后再次发送请求，获取对应的新闻评论内容
      * 3、新闻内容获取失败则不需要再次发送请求。
      *
      * */
      function AjaxG(url) {
          $.get(url, (data) =>{
              console.log(data)
              let url='http://localhost:3000'+data.commentsUrl
              SX.next(url)
          })
      }

      function* sendXml() {
          let url=yield   getNews('http://localhost:3000/news?id=3')
          yield   AjaxG(url)
      }  
      let SX = sendXml()
      SX.next();
        //控制流管理
      //源码:
      step1(function (value1) {
        step2(value1, function(value2) {
          step3(value2, function(value3) {
            step4(value3, function(value4) {
              // Do something with value4
            });
          });
        });
      });
      //改写: promise
      Promise.resolve(step1)
      .then(step2)
      .then(step3)
      .then(step4)
      .then(function (value4) {
        // Do something with value4
      }, function (error) {
        // Handle any error from step1 through step4
      })
      .done();
      //改写:generator
      function* longRunningTask(value1) {
        try {
          var value2 = yield step1(value1);
          var value3 = yield step2(value2);
          var value4 = yield step3(value3);
          var value5 = yield step4(value4);
          // Do something with value4
        } catch (e) {
          // Handle any error from step1 through step4
        }
      }
      //然后，使用一个函数，按次序自动执行所有步骤。

      scheduler(longRunningTask(initialValue));

      function scheduler(task) {
        var taskObj = task.next(task.value);
        // 如果Generator函数未结束，就继续调用
        if (!taskObj.done) {
          task.value = taskObj.value
          scheduler(task);
        }
      }
    </script>
  </body>
</html>
